### 1.常用居中方法

##### 水平居中

- 子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。下面进行分析：

    -  行内元素：对父元素设置text-align:center;

    - 定宽块状元素: 设置左右margin值为auto;

    - 不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center;

    - 通用方案: flex布局，对父元素设置display:flex;justify-content:center;

##### 垂直居中

- 垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。

    - 父元素一定，子元素为单行内联文本：设置父元素的height等于行高line-height

    - 父元素一定，子元素为多行内联文本：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;

    - 块状元素:设置子元素position:fixed（absolute），然后设置margin:auto;

    - 通用方案: flex布局，给父元素设置{display:flex; align-items:center;}。

 

### 2.单列布局(特征：定宽、水平居中)


- 常见的单列布局有两种：

    - 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。

    - 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。

### 3. 二列&三列布局

 


- 二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。

    - a. float+margin

        - 原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。


    - b. position+margin

        - 原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。

    - c. 圣杯布局(float + 负margin + padding + position)

        - 原理说明：主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。
    - d. 双飞翼布局(float + 负margin + margin)

        - 原理说明：双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。

##### 与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。
```

<div class="a" style="display: flex">
    <div class="b" style="flex: 1"></div>
    <div class="c" style="width: 200px"></div>
</div>
```

##### 传统的布局方法基于盒状模型，依赖display属性 +position属性 +float属性，逻辑相对复杂，对于实现一些特殊效果，例如垂直居中，尤其复杂繁琐。而flex布局中的flex容器可以根据实际可用空间动态调整子元素的宽高比和顺序，使元素能够尽可能地利用可用空间，同时也能通过缩小来避免超出。flex布局提供了一套简便、完整、响应式的布局方案。

